;;; The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:

;;; 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

;;; Let us list the factors of the first seven triangle numbers:

;;;  1: 1
;;;  3: 1,3
;;;  6: 1,2,3,6
;;; 10: 1,2,5,10
;;; 15: 1,3,5,15
;;; 21: 1,3,7,21
;;; 28: 1,2,4,7,14,28
;;; We can see that 28 is the first triangle number to have over five divisors.

;;; What is the value of the first triangle number to have over five hundred divisors?

; First, we can generate the nth triangle by summing the postive natural numbers up to n:
(defn nth-triangle [n]
  (/ (* n (+ n 1)) 2))

(nth-triangle 1) ; => 1
(nth-triangle 2) ; => 3
(nth-triangle 3) ; => 6
(nth-triangle 4) ; => 10
(nth-triangle 5) ; => 15

; Looking good!

; Second, we need a function which counts divisors:
(defn num-of-divisors [n]
  (->> (range 1 (inc n))
       (filter #(zero? (rem n %)) ,,,)
       (count ,,,)))

(num-of-divisors 1) ; => 1
(num-of-divisors 3) ; => 2
(num-of-divisors 6) ; => 4
(num-of-divisors 10) ; => 4
(num-of-divisors 15) ; => 4
(num-of-divisors 21) ; => 4
(num-of-divisors 28) ; => 6

; Again, looking good! (Although it's maybe a bit slow at O(n)...)

; Now, all we need to do is loop over the triangles, checking the divisors as we go:
(defn find-triangle [d]
  (loop [n 1]
    (if (> (num-of-divisors (nth-triangle n)) d)
      (nth-triangle n)
      (recur (inc n)))))

(find-triangle 1) ; => 3
(find-triangle 3) ; => 6
(find-triangle 4) ; => 28

; Works great! But it's _way_ too slow for large d. Hmm.

; A lot of time would be saved if there were a quicker way of counting divisors.
; Why not only check up to sqrt(n), counting each divisor twice (except for sqrt(n))? After all, divisors come in pairs!
(defn num-of-divisors2 [n]
  (->> (range 1 (inc (int (Math/sqrt n))))
       (filter #(zero? (rem n %)) ,,,)
       (count ,,,)
       (#(if (zero? (rem n (Math/sqrt n)))
           (dec (* 2 %))
           (* 2 %)))))

(num-of-divisors2 1) ; => 1
(num-of-divisors2 3) ; => 2
(num-of-divisors2 6) ; => 4
(num-of-divisors2 10) ; => 4
(num-of-divisors2 15) ; => 4
(num-of-divisors2 21) ; => 4
(num-of-divisors2 28) ; => 6

; It works! So:
(defn find-triangle2 [d]
  (loop [n 1]
    (if (> (num-of-divisors2 (nth-triangle n)) d)
      (nth-triangle n)
      (recur (inc n)))))

(find-triangle2 1) ; => 3
(find-triangle2 3) ; => 6
(find-triangle2 4) ; => 28

(find-triangle2 500)

; MUCH quicker! :D
